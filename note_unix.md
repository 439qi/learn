# Unix 系统  
>
> The Linux Programming Interface.pdf -- Michael KerrisK
>

## Extra

### 例程(routine)、过程(procedure)、进程(process)、线程(thread)、协程(coroutine)

例程、过程、子程序都是函数在不同时期的叫法

协程，单线程多任务的工作方式

## 历史

### Unix

1969 年由AT&T的贝尔实验室(Bell Laboratories)的Ken Thompson开发，基于先前AT&T、通用电气和MIT合作的操作系统MULTICS(Multiplexed Information and Computing Service)  

> 在Unix开发过程中，其同事Dennis Ritchie设计了C语言用于编写Unix内核

### BSD

Thompson1975/1976学年作为访问专家任职位于伯克利的母校加利福尼亚大学，并在此期间诞生了Unix变种BSD(Berkeley Software Distribution)

> 还诞生了许多工具，包括C shell，vi等

### GNU与Linux

1. GNU  
    1984年MIT的Richard Stallman出于反对计算机制造商对于操作系统的产权限制——即用户无法获取所购买软件的源代码且无法自由复制、改动、分发这些软件，启动了GNU(GNU's Not Unix)项目  

    > 在此期间诞生了通用公共许可证(GPL, General Public License)，任何使用该许可证的软件必须开放源代码且允许自由分发，且这些软件的改动版本也必须使用GPL许可证

    GNU项目产生了许多Unix-like系统可移植程序，包括Emacs，GCC等，但并没有一个能工作的内核

2. Linux内核  
    荷兰的大学教授Andrew Tanebaum出于教学目的编写了Minix  
    Linus Torvalds基于Minix开发了能运行GNU程序的基础内核
    其余程序员加入并逐渐完善Linux内核

### 标准化

大量具有不同特性的Unix变种使得软件难以移植  

1. C语言标准的提出使得仅使用标准C语言库的程序能够在任意操作系统间移植
2. POSIX(Portable Operating System Interface)标准  
    该标准包含Unix系统调用的C语言接口、shell程序和工具、线程及网络编程等  
    确保源代码级别的可移植性  
    NFY

## 基础概念

### 内核(kernel)

管理和分配计算机资源的核心软件  

#### 内核的任务

- 进程管理
- 进程调度
- 内存管理
- 文件系统
- 外部设备访问
- 网络
- 系统调用API

#### 内核态(kernel mode)和用户态(user mode)

现代处理器架构允许CPU运行在两种模式：用户态和内核态  
相应地，内存被标记为用户空间和内核空间；用户态的CPU仅能访问用户空间，内核态的CPU能访问全部内存空间  
部分操作仅能在内核态执行

### Shell

shell是用于读取用户输入的命令并执行对应程序的专用程序  
有时也称作**命令解释器**(command interpreter)  
但在Unix系统中，命令解释器是内核的一部分，shell是用户进程

shell脚本是包含shell命令的脚本文件  
shell具备编程语言的一些特性以支持shell脚本：变量、循环、条件语句、IO和函数

### 用户和组

#### 用户(Users)

系统的每个用户被独特的用户名和UID(User ID)唯一标识  
用户信息记录在/etc/passwd，其包含

- 用户名
- UID
- 用户所属组的GID
- Home目录
- 登录shell
- 密码  
    出于安全原因，密码不再存储在/etc/passwd，而是存储在仅特权可读的影子密码文件/etc/shadow

#### 组(Groups)

为便于管理，用户可被按组管理  
组信息记录在/etc/group，其包含

- 组名
- GID
- 用户列表

#### 超级用户(Superuser)

超级用户具有系统内的特权，能通过系统的所有权限检查  
超级用户UID为0，用户名通常为`root`

### 单目录层次，目录，链接和文件

Unix内核使用单一层次目录结构来管理文件，即所有文件/目录均为根目录的子节点

#### 文件类型

Unix所有文件都被标识了类型

- **普通数据文件**(ordinary data files)
- **设备**(devices)
- **管道**(pipes)
- **套接字**(sockets)
- **目录**(directories)  
    目录属于特殊的文件，其内容为文件名到文件引用的映射表  
    > 文件名到文件引用的映射称为**链接**(links)，也称为**硬链接**(hard links)  

    每个目录至少包含两个条目
  - `.` ：表示当前目录，即目录自身
  - `..`  : 表示父目录；对于根目录，`..`指向它自身
- 符号链接(symbolic links)  
    也称为**软链接**(soft links)  
    符号链接以文件的形式而非目录内映射表条目的形式存在  
    其内容为另一个文件的文件名，称之为**目标**(target)  
    当符号链接指向的文件不存在时，称之为**空悬链接**(dangling link)

    当系统调用接收到路径名时，会对路径中的每个符号链接递归解引用并替换，直至路径名中不包含任何符号链接  

#### 文件名

大多数Linux文件系统支持最大255字符的文件名  
文件名可以为`/`和`\0`之外的任意字符  
但建议只使用**可移植文件名字符集**(portable filename character set)，`[-._a-zA-Z0-9]`，以及避免使用`-`开头，以避免一些字符在shell、正则表达式等情况下的特殊含义

#### 当前工作目录(current working directory)

每个进程都有其当前工作目录(或简称为当前目录或工作目录)，其表示该进程的当前所在目录  
子进程会继承父进程的当前工作目录  

对于shell，可通过`cd`命令改变当前工作目录

#### 路径名

分为绝对路径和相对路径

- 绝对路径  
    以`/`开头，表示文件相对于根目录的路径
- 相对路径  
    不以`/`开头，表示文件相对于进程的当前工作目录的路径

#### 文件所有权(ownership)和权限(permissions)

每个文件都有一个与其相关联的UID和GID，表明文件所有者和所属的组  

在访问文件的角度，系统将用户分为三类：文件所有者、组的成员、其余用户  
每类用户可设置三种权限  

| 权限| 文件| 目录|
|- |-|-|
| **读**(read)  | 读取文件内容| 读取目录下文件  |
| **写**(write)  | 修改文件内容| 增加、删除、修改文件名 |
| **执行**(execute)  | 执行文件| 将该目录设置为当前工作目录 |

### [文件I/O模型](#文件io通用io模型)

I/O的通用性概念：同一个系统调用(`open()`、`close()`等)可用于各类型的文件以及设备，由内核转换为确当的文件系统或设备驱动操作，内核对外只提供以提供一种文件类型，即连续字节流  
Unix系统不使用EOF字符，当读取为空时即视为文件结尾

#### 文件描述符(file descriptor)

I/O系统调用使用非负整数，称之为文件描述符来打开文件  
通常传递路径名给`open()`以返回文件描述符  

当一个进程被shell打开时会继承三个已打开的文件描述符：

- 0，**标准输入**(standard input)
- 1，**标准输出**(standard output)
- 2，**标准错误**(standard error)

在交互性的shell和程序中，三个文件描述符对应终端  
在[**标准输入输出库**(stdio library)](#标准输入输出库)中，三个文件描述符对应文件流`stdin`,`stdout`,`stderr`

#### 标准输入输出库

`fopen()`, `fclose()`, `scanf()`, `printf()`等标准库I/O函数是对I/O系统调用的封装

### 程序(programs)

#### 过滤器(filters)

过滤器通常指从`stdin`读取输入，进行转换后输出到`stdout`的程序

#### 命令行参数

C程序可以获取命令行参数，形如

```cpp
int main(int argc, char *argv[]);
```

### 进程

进程是正在执行的程序的实例  
当程序被执行时，内核将其代码加载到虚拟空间，为程序变量分配空间，并记录该进程相关信息(如进程ID，终止状态等)

#### [进程内存布局](#进程的内存布局)

进程在逻辑上可以分为如下部分，称为**段**(segment)

- 文本：程序的指令
- 数据：程序静态变量
- 堆：用于动态分配额外内存
- 栈：随程序执行动态变化的内存，存储局部变量和函数链接信息

#### 进程创建和程序执行

进程通过系统调用`fork()`创建新的进程  
调用`fork()`的进程称为父进程，被创建的进程称为子进程

### 内存映射

系统调用`mmap()`在进程的虚拟地址空间创建内存映射，分为

- 文件映射(file mapping)  
    也被称为**基于文件的映射**(file-based mapping)或**内存映射文件**(MMF, memory-mapped file)  

    操作系统提供的一种高效文件IO技术  
    当需要频繁读取的文件数据、文件共享、进程通信时，将文件内容映射到内存，通过内存读写的方式操作磁盘文件

  - 效率高  
    映射到操作系统内核态内存而非编程语言内存空间，效率高
  - 自动按需映射  
    由操作系统自动映射，且只需要将使用的部分内容映射到内存
  - 多映射共享  
    同一个文件可被多个进程映射到各自内存，且由操作系统进行同步  

- 匿名映射(anonymous mapping)  
    匿名映射没有与之对应的文件，被映射的内存页被初始化为0

## 系统编程概念

### 系统调用

系统调用是内核的受控入口点，允许进程请求内核执行特定操作  

- 系统调用将处理器状态从用户态变为内核态，使得CPU可以访问受保护的内核内存
- 系统调用集是固定的
- 系统调用可能包含参数，用于子内核空间和用户空间之间交换信息

程序调用系统调用过程如下

1. 应用程序调用C库的包装函数
2. 包装函数将参数拷贝到特定寄存器
3. 包装函数将系统调用编号拷贝到一个特定寄存器(%eax)
4. 包装函数执行**陷入**(trap)指令(int 0x80)
5. 内核调用`system_call()`例程处理陷入
    1. 保存寄存器状态到内核栈
    2. 检查系统调用编号合法性
    3. 调用适当的系统调用服务例程
    4. 从内核栈恢复寄存器状态，并将系统调用返回值入栈
    5. 返回到包装函数，同时将处理器变为用户态
6. 如果系统调用返回值指示了一个错误，则包装函数设置全局变量`errno`然后返回到调用者

### 库函数

NFY

## 线程(thread)

线程是允许应用程序并发执行多个任务的机制  

一个进程可以包含多个线程，多个线程之间共享如下属性：

- 全局内存区域
- 进程ID和父进程ID
- 进程组ID和会话ID  
- 控制终端
- 控制凭证
- 打开的文件描述符
- `fcntl()`创建的记录锁
- 信号(signal)
- 文件权限掩码、当前工作目录、根目录
- 间隔定时器和POSIX定时器  
- NOT FINISHED

各线程之间独有的属性如下：

- 线程ID
- **信号掩码**(signal mask)
- 线程特有数据???
- 备选信号栈
- `errno`变量
- 浮点型环境
- 实时调度策略和优先级
- CPU亲和力(affinity)，Linux特有
- 能力(capability)，Linux特有
- 栈，本地变量和函数的调用**链接**(linkage)信息

### Pthreads API

1995年POSIX.1c对POSIX线程API进行了标准化，并被SUSv3所采纳

#### 线程数据类型

Pthreads API定义了如下数据类型，但并未规定如何实现，故程序应避免依赖于如下数据类型的结构或内容

|数据类型|描述|
|-|-|
|pthread_t|线程ID|
|pthread_mutex_t|**互斥锁**(mutex)|
| pthread_mutexattr_t| 互斥锁属性|
|pthread_cond_t| **条件变量**(condition variable)|
|pthread_condattr_t| 条件变量属性|
|pthread_key_t| 线程特有数据的键值|
|pthread_once_t|一次性初始化**控制上下文**(control context)|

#### errno

传统Unix API，error为全局变量  
在多线程程序中，每个线程有其独有的errno

errno被定义为宏，可展开为函数调用，返回值为可修改的[左值](note_C++.md/#值种类value-categories-对于表达式按值分类)

## 进程

### 程序 Programs

程序是一个描述如何在运行时构造[进程](#进程-processes)的文件，包含如下信息

- **二进制标识**(Binary format identification)
    描述可执行文件格式的元数据，如今多使用**ELF**(Executable and Linking Format)
- **机器语言指令**(Machine-language instructions)
- **程序入口点地址**(Program entry-point address)
- **数据**(Data)
- **符号和重定位表**(Symbol and relocation tables)  
    描述程序内部函数/变量的地址和位置
- **共享库和动态链接信息**(Shared-library and dynamic-linking information)  
    描述程序所需的共享库及其路径
- 其他信息

### 进程 Processes

进程是一个正在执行的程序的实例，或者说  
由内核定义，并分配了系统资源以执行程序的抽象实体

#### 进程ID和父进程ID

进程ID(PID, Process ID)是一个唯一标识某个进程的正整数  
除了部分系统进程，进程和进程ID之间没有固定的关联  

```cpp
#include<unistd.h>
pid_t getpid(); //返回进程ID  
pid_t getppid(); //返回父进程ID
```  

在Linux内核2.4及更早版本，进程ID上限为内核中的常量 `PID_MAX` 32767  
在之后的版本中，进程ID上限为`/proc/sys/kernel/pid_max` 文件中的值定义，其值为进程ID上限+1，默认为32768  
当达到上限后，进程ID计数器会重置为300，因为300以下的一些ID往往是系统进程ID，在300以下搜索可用ID会浪费时间

父进程ID表示了系统中所有进程间的类树关系，所有进程均由根节点`init`直接或间接创建  
当一个进程的父进程终止时，其会被`init`进程接管

#### 进程的内存布局

进程的内存由被称为**段**(segment)或**分区**(section)的多个部分组成  

- 文本段(text segment)  
    包含程序的机器指令  
    该段被设置为只读且共享，防止进程意外修改其指令以及多个进程共享
- 已初始化数据段(initialized data segment)  
    包含显式初始化的全局变量和静态变量
- 未初始化数据段(uninitialized data segment)  
    未显式初始化的全局变量和静态变量
- **栈**(stack)  
    由**栈帧**(stack frames)组成  
    每个栈帧包含其对应函数的参数、局部变量和返回值  
    向下增长
- **堆**(heap)  
    用于运行时动态分配的内存  
    向上增长

#### 虚拟内存管理

由于程序的**引用局部性**(locality of reference)，在执行程序时可以在内存中仅保留部分地址空间

- 空间局部性(spatial locality)  
    因为程序指令的顺序执行，程序具有引用最近访问过的内存地址附近的内存地址的趋势  
- 时间局部性(temporal locality)  
    因为循环，程序具有短期内访问最近访问过的内存地址的趋势  

虚拟内存将程序使用的内存划分为固定大小的小单元，称之为**页**(pages)  
相对应地，内存被划分为相同大小的**页帧**(page frames)  

驻留在内存中的部分页称为**驻留集**(resident set)，其余部分保留在**交换区**(swap area)  
当进程所需的页不在内存中时，会产生**缺页错误**(page fault)，内核暂停该进程的执行直到该页被加载进内存

内核使用**页表**(page table)维护程序的逻辑/虚拟地址空间和实际地址空间的映射关系  
START FROM HERE

## 管道和 FIFO

> FIFO 也被称作**具名管道**(named pipe)，相对地，普通管道也被称为匿名管道

### 管道

**管道**(pipe)是 UNIX 系统上最早的进程间通信手段，其提供了**相关联**进程间传输数据的方法  
> **相关联**(related)指进程关系为父子进程，或具有相同的祖先进程  

管道是内核内存中的一块缓冲区，其大小取决于操作系统实现  

写进程的标准输出被定向到管道的写入端，而读进程的标准输入被重定向到管道的读取端 ；对于使用管道的进程意识不到管道的存在

管道中的数据是单纯的字节流，只能顺序访问，无法随机访问

### 管道读写

当管道满时，向管道中写入操作会被阻塞  

尝试读取空管道的操作会阻塞，直到至少一个字节被写入到管道  
当管道的写入端关闭时，管道中会被写入一个 EOF

UNIX 标准定义的管道是单向的，即管道的一端仅用于写入，另一端仅用于读取  
也有操作系统实现了双向的管道，但其并不在 UNIX 标准中，在不同操作系统间可能会有移植性问题

当多个进程同时写入单个管道时  

- 若单次写入数据大小不超过 `PIPE_BUF` 时，管道保证该次写入操作是原子性的，即数据不会混杂在一起  
    具体地，`write()` 函数会阻塞直至管道有足够的空间，再一次将数据写入

- 若单次写入数据大于 `PIPE_BUF` 时，系统内核会将数据分为多个小块数据，当前一块被读走后再向管道中添加后续的数据块（`write()` 会阻塞直至所有数据都被写入管道）  
    具体地，`write()` 会先向管道中写入尽可能多的数据然后阻塞，直至有进程读取而移除了部分数据再写入后续数据；或阻塞时被信号中断，则会恢复并直接返回已写入的字节数

    > `PIPE_BUF` 的具体大小取决于操作系统实现  

NFY

### FIFO/具名管道(named pipe)

FIFO 是管道概念的一个变种，不同在于其能在**任意**进程间传输数据，且除非显式删除否则将持久存在  
FIFO 有文件系统中的名称，打开方式与常规文件相同，读取和写入进程可以像使用文件一样使用 FIFO  

FIFO 也分为输入端和输出端，且会自同步，即只有一端被打开时会阻塞，直至另一端也被某个进程打开  
> 虽然标准要求同步，但绝大多数的操作系统实现中，可以传递参数使得函数立即返回而非阻塞，这在一定程度上破坏了 FIFO 的 I/O 模型

NFY
